---
import GuideLayout from "../../layouts/GuideLayout.astro";

const title = "Lambda concurrency and cold starts (cost pitfalls)";
const description =
  "A practical guide to Lambda concurrency and cold starts: how they affect duration and cost, when provisioned concurrency is worth it, and what to measure to avoid surprise bills.";
const faqs = [
  {
    q: "Does concurrency itself cost money?",
    a: "Not directly for on-demand Lambdas. Cost usually comes from invocations and GB-seconds. However, provisioned concurrency adds a baseline cost because you pay for pre-initialized capacity.",
  },
  {
    q: "How do cold starts affect cost?",
    a: "Cold starts often increase duration (more GB-seconds). If cold starts happen frequently, they can noticeably increase monthly compute cost and worsen latency.",
  },
  {
    q: "When is provisioned concurrency worth it?",
    a: "For latency-sensitive paths with frequent cold starts where the business value of lower tail latency justifies the baseline cost. It’s usually not worth it for spiky background jobs.",
  },
];
---
<GuideLayout
  title={title}
  description={description}
  canonicalPath="/guides/aws-lambda-concurrency-and-cold-starts"
  lastUpdated="2026-01-27"
  faqs={faqs}
>
  <p>
    Concurrency and cold starts matter for both <strong>latency</strong> and <strong>cost</strong>. Cold starts often
    increase duration, which increases GB-seconds. Provisioned concurrency can reduce cold starts, but it adds a baseline
    “always-on” cost. This page explains how to think about the trade-off and what to measure.
  </p>

  <h2>How concurrency relates to cost</h2>
  <ul>
    <li>
      <strong>On-demand</strong>: cost ≈ requests + GB-seconds. Concurrency is a result of traffic; it’s not a separate fee.
    </li>
    <li>
      <strong>Provisioned concurrency</strong>: adds baseline cost because you pay to keep capacity warm.
    </li>
  </ul>
  <p class="muted">
    Pricing checklist: <a href="/guides/aws-lambda-pricing/">Lambda pricing</a>
  </p>

  <h2>Why cold starts can raise your bill</h2>
  <p>
    If a cold start adds extra initialization time, it increases the billed duration for that invocation. If cold starts
    happen often (spiky traffic, low steady usage), the “extra duration” can become a meaningful portion of monthly
    GB-seconds.
  </p>
  <ul>
    <li>Spiky workloads: many cold starts per day/week.</li>
    <li>Large bundles and heavy init: bigger cold start penalty.</li>
    <li>Downstream dependency latency: cold starts often correlate with other slow paths.</li>
  </ul>

  <h2>A practical way to decide on provisioned concurrency</h2>
  <ol>
    <li>Identify the latency-sensitive path (user-facing API vs background job).</li>
    <li>Measure how often cold starts happen and how much duration they add.</li>
    <li>Estimate the monthly baseline cost of provisioned concurrency for the hours you need it.</li>
    <li>Decide if the SLA/UX improvement is worth the baseline.</li>
  </ol>
  <p class="muted">
    Tip: apply provisioned concurrency only during business hours for endpoints that need it; don’t blanket-enable.
  </p>

  <h2>Cost pitfalls to watch for</h2>
  <ul>
    <li>Enabling provisioned concurrency globally (adds baseline cost everywhere).</li>
    <li>Keeping a tiny steady traffic pattern that triggers frequent cold starts and long-tail latency.</li>
    <li>Retry storms during incidents multiplying invocations (and cold starts) in a short time window.</li>
    <li>Large initialization work (loading big dependencies, scanning config) inflating duration.</li>
    <li>Running functions in a VPC and then discovering NAT/egress costs and longer startup times.</li>
  </ul>

  <h2>What to measure (so you can validate a change)</h2>
  <ul>
    <li>Invocation count and duration distribution (p50/p95) before vs after.</li>
    <li>Error rate and retries (spikes often explain spend jumps).</li>
    <li>For provisioned concurrency: baseline hours enabled vs actual demand windows.</li>
    <li>Log ingestion GB/day (cold start debugging often increases log volume).</li>
  </ul>

  <h2>Related guides and tools</h2>
  <div class="btn-row">
    <a class="btn" href="/guides/aws-lambda-cost-optimization/">Lambda cost optimization</a>
    <a class="btn" href="/calculators/aws-lambda-cost-calculator/">Lambda cost calculator</a>
    <a class="btn" href="/guides/aws-lambda-vs-fargate-cost/">Lambda vs Fargate</a>
  </div>

  <h2>Sources</h2>
  <ul>
    <li>
      <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html" target="_blank" rel="nofollow noopener">
        AWS Lambda concurrency documentation
      </a>
    </li>
    <li>
      <a href="https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html" target="_blank" rel="nofollow noopener">
        Provisioned concurrency documentation
      </a>
    </li>
  </ul>
</GuideLayout>
