---
import GuideLayout from "../../layouts/GuideLayout.astro";

const title = "ECS task sizing: how to pick CPU and memory (and estimate task count)";
const description =
  "A practical ECS task sizing guide: choose vCPU/memory from measured usage, pick a utilization target, estimate average task count, and avoid the sizing mistakes that cause cost spikes.";
---
<GuideLayout
  title={title}
  description={description}
  canonicalPath="/guides/aws-ecs-task-sizing"
  lastUpdated="2026-01-27"
  faqs={[
    {
      q: "What's the fastest way to size ECS tasks?",
      a: "Start from measured averages and p95s: CPU and memory used by the service over time. Choose per-task vCPU/memory, target a realistic utilization band, then estimate required task count with a sizing calculator.",
    },
    {
      q: "Should I size from peak usage?",
      a: "Use peaks to set headroom and autoscaling limits, but plan monthly cost from average capacity. Peak-only sizing usually overprovisions and increases spend.",
    },
    {
      q: "What causes ECS cost spikes?",
      a: "Over-sized tasks, scaling on noisy signals, retry storms, and ignored non-compute costs (load balancers, logs, NAT/egress).",
    },
  ]}
>
  <p>
    ECS task sizing is a balancing act: too small and you thrash (restarts, timeouts, throttling), too large and you pay
    for idle capacity. The best approach is to size from <strong>measured averages</strong>, keep headroom with a
    deliberate utilization target, and validate the result with a busy-week scenario.
  </p>

  <h2>Step 1: measure demand (use a representative window)</h2>
  <ul>
    <li><strong>CPU</strong>: average and p95 usage for the service (not only peak).</li>
    <li><strong>Memory</strong>: average and p95 usage (include deploy/cold-cache windows).</li>
    <li><strong>Traffic shape</strong>: steady, bursty, or time-of-day (helps estimate average tasks).</li>
    <li><strong>Error/retry signals</strong>: timeouts and retries can multiply load and invalidate "normal week" sizing.</li>
  </ul>

  <h2>Step 2: pick per-task vCPU and memory</h2>
  <ul>
    <li>
      Choose the smallest task size that meets stability and latency targets at steady load.
    </li>
    <li>
      Prefer scaling out (more tasks) over a single huge task when it improves utilization and reduces tail latency.
    </li>
    <li>
      Keep memory headroom for spikes, GC, caching, and temporary buffers. Memory is often the real limiter.
    </li>
  </ul>
  <p class="muted">
    A common failure mode is to pick "round numbers" (1 vCPU / 2 GB) and never revisit. Treat task size as a model input
    that evolves with the service.
  </p>

  <h2>Step 3: pick a utilization target</h2>
  <p class="muted">
    Utilization target is the "planning headroom" you keep so scaling and deploys work without timeouts.
  </p>
  <ul>
    <li>Lower target (more headroom): more stable, higher cost.</li>
    <li>Higher target (less headroom): cheaper, but more sensitive to bursts and slow dependencies.</li>
    <li>For spiky services, separate baseline and burst capacity instead of one target.</li>
  </ul>

  <h2>Step 4: estimate average task count (the billing driver)</h2>
  <p>
    The bill tracks <strong>average running tasks over time</strong>, not the peak moment. A practical sizing model is:
  </p>
  <pre><code>{`tasks ~= max(
  cpu_demand / (task_vcpu * target_utilization),
  mem_demand / (task_mem_gb * target_utilization)
)`}</code></pre>
  <div class="btn-row">
    <a class="btn" href="/calculators/aws-ecs-task-sizing-calculator/">ECS task sizing calculator</a>
    <a class="btn" href="/guides/aws-ecs-pricing/">ECS pricing</a>
  </div>

  <h2>Worked example (order-of-magnitude)</h2>
  <ul>
    <li>Average CPU demand: 6 vCPU</li>
    <li>Average memory demand: 18 GB</li>
    <li>Task size: 1 vCPU / 3 GB</li>
    <li>Target utilization: 0.7</li>
    <li>CPU-based tasks: 6 / (1 * 0.7) ~= 9</li>
    <li>Memory-based tasks: 18 / (3 * 0.7) ~= 9</li>
  </ul>
  <p class="muted">
    If you size tasks larger (2 vCPU / 6 GB) but your service is not actually CPU-bound, you can reduce task count but
    also reduce packing flexibility and increase idle within each task. Validate with real utilization.
  </p>

  <h2>Convert task sizing to cost (Fargate vs EC2)</h2>
  <ul>
    <li><strong>ECS on Fargate</strong>: vCPU-hours + memory GB-hours for running tasks.</li>
    <li><strong>ECS on EC2</strong>: instance-hours (plus EBS and snapshots if you attach volumes).</li>
  </ul>
  <div class="btn-row">
    <a class="btn" href="/calculators/aws-fargate-cost-calculator/">Fargate cost</a>
    <a class="btn" href="/calculators/ec2-cost-calculator/">EC2 cost</a>
    <a class="btn" href="/calculators/aws-ecs-ec2-vs-fargate-cost-calculator/">ECS EC2 vs Fargate</a>
  </div>

  <h2>Cost pitfalls that look like "bad sizing"</h2>
  <ul>
    <li><strong>Noisy scaling</strong>: CPU% spikes trigger oscillation and keep average tasks high.</li>
    <li><strong>Retry storms</strong>: timeouts multiply requests, tasks, logs, and transfer.</li>
    <li><strong>Logs</strong>: ingestion + retention can exceed compute for high-traffic or verbose services.</li>
    <li><strong>NAT/egress</strong>: image pulls and external calls can create large variable network costs.</li>
  </ul>
  <p class="muted">
    Full model: <a href="/guides/aws-ecs-cost-model-beyond-compute/">ECS cost model beyond compute</a>.
  </p>

  <h2>Validation checklist</h2>
  <ul>
    <li>Validate average and p95 CPU/memory over at least 7 days (include a busy day).</li>
    <li>Validate task count over time (average vs peak) and compare to the sizing model.</li>
    <li>Validate latency and error rate during deploys and scaling events.</li>
    <li>Validate non-compute: log ingestion GB/day and NAT processed GB during busy windows.</li>
  </ul>

  <h2>Sources</h2>
  <ul>
    <li>
      ECS task definitions:{" "}
      <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html" rel="nofollow noopener" target="_blank">
        docs.aws.amazon.com
      </a>
    </li>
    <li>
      ECS service autoscaling:{" "}
      <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-auto-scaling.html" rel="nofollow noopener" target="_blank">
        docs.aws.amazon.com
      </a>
    </li>
  </ul>
</GuideLayout>

