---
import GuideLayout from "../../layouts/GuideLayout.astro";

const title = "CloudWatch Logs Insights cost optimization (reduce GB scanned)";
const description =
  "A practical playbook to reduce CloudWatch Logs Insights costs: measure GB scanned, fix query patterns, time-bound dashboards, and avoid repeated incident scans.";
---
<GuideLayout
  title={title}
  description={description}
  canonicalPath="/guides/aws-cloudwatch-logs-insights-cost-optimization"
  lastUpdated="2026-01-27"
  faqs={[
    {
      q: "What drives Logs Insights cost?",
      a: "GB scanned by queries. Frequent broad queries over long time ranges are the fastest way to create a large bill.",
    },
    {
      q: "How do I reduce GB scanned without losing debug ability?",
      a: "Make queries time-bounded, filter early, split noisy logs into separate groups, and avoid dashboards that re-scan large ranges continuously.",
    },
  ]}
>
  <p>
    Logs Insights pricing is usually a function of <strong>GB scanned</strong>. To reduce cost, you reduce how many bytes
    your queries scan. The highest leverage fixes are almost always about <strong>query shape</strong> and
    <strong>log organization</strong>, not about deleting logs blindly.
  </p>

  <h2>Step 0: measure before optimizing</h2>
  <ul>
    <li>Identify the top 10 queries by GB scanned (dashboards + ad-hoc investigations).</li>
    <li>Measure scanned GB/day for a representative week, including incident days.</li>
    <li>Identify which log groups drive scanning (noisy vs high-signal).</li>
  </ul>
  <div class="btn-row">
    <a class="btn" href="/calculators/cloudwatch-logs-insights-cost-calculator/">Logs Insights cost</a>
    <a class="btn" href="/guides/aws-cloudwatch-logs-insights-pricing/">Logs Insights pricing</a>
  </div>

  <h2>High-leverage levers</h2>
  <ul>
    <li>
      <strong>Time-bound every query</strong>: avoid “last 30 days” defaults; start with 15–60 minutes and expand only
      if needed.
    </li>
    <li>
      <strong>Filter early</strong>: restrict by service, path, status code, or request id before expensive parsing and sorting.
    </li>
    <li>
      <strong>Split noisy logs</strong>: keep debug/verbose logs separate so you don’t scan them during normal operations.
    </li>
    <li>
      <strong>Reduce repeated scans</strong>: dashboards should query small windows; incident playbooks should avoid scanning “all time” repeatedly.
    </li>
    <li>
      <strong>Make queries reusable</strong>: save “golden queries” that are scoped and time-bounded to avoid ad-hoc broad scans.
    </li>
  </ul>

  <h2>Query patterns that usually scan less</h2>
  <ul>
    <li>
      <strong>Start narrow</strong>: 15 minutes, one log group, one service, then widen if the signal is missing.
    </li>
    <li>
      <strong>Filter before parsing</strong>: restrict by a simple substring or status code early, then parse JSON fields.
    </li>
    <li>
      <strong>Split debug logs</strong>: keep verbose logs in separate groups so normal queries don’t scan them.
    </li>
    <li>
      <strong>Use “top N” sparingly</strong>: sorting large ranges can encourage bigger scans; scope first.
    </li>
  </ul>
  <p class="muted">Example query shape (pseudocode):</p>
  <pre><code>{`fields @timestamp, @message
| filter @message like /ERROR/
| filter service = "payments"
| sort @timestamp desc
| limit 50`}</code></pre>

  <h2>Operational guardrails</h2>
  <ul>
    <li>Dashboards: default to short windows (15m/1h) and avoid auto-refresh on long ranges.</li>
    <li>Incident playbooks: prefer “narrow then widen” steps instead of repeated “search everything”.</li>
    <li>Ownership: track who owns the top scanning dashboards and review them quarterly.</li>
  </ul>

  <h2>Common cost traps</h2>
  <ul>
    <li>
      <strong>Wide time ranges</strong>: scanning 7 days vs 1 hour can be a 168× jump in scanned GB.
    </li>
    <li>
      <strong>Dashboards as scanners</strong>: auto-refresh dashboards can re-scan the same large dataset all day.
    </li>
    <li>
      <strong>Unbounded search patterns</strong>: “find error anywhere” across all groups becomes expensive at scale.
    </li>
    <li>
      <strong>Noisy log groups</strong>: high-volume success logs dominate scan volume for simple questions.
    </li>
  </ul>

  <h2>Validation checklist</h2>
  <ul>
    <li>For every “optimized query”, compare scanned GB before vs after.</li>
    <li>Confirm dashboards are time-bounded and do not scan long ranges on auto-refresh.</li>
    <li>Confirm noisy logs are separated or sampled so routine queries scan high-signal data.</li>
    <li>After changes, validate incident workflows still work (debug ability preserved).</li>
  </ul>

  <h2>Sources</h2>
  <ul>
    <li>
      CloudWatch pricing:{" "}
      <a href="https://aws.amazon.com/cloudwatch/pricing/" rel="nofollow noopener" target="_blank">
        aws.amazon.com/cloudwatch/pricing
      </a>
    </li>
    <li>
      Logs Insights query syntax:{" "}
      <a
        href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html"
        rel="nofollow noopener"
        target="_blank"
      >
        docs.aws.amazon.com
      </a>
    </li>
  </ul>
</GuideLayout>
